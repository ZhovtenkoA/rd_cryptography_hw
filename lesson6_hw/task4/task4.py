from Crypto.Util.number import long_to_bytes

# Исходные данные
n = 30460296206281253605887131667441042408833105116654370140736576080711297109384941590369941855116386695157474206375705248890458232777575365270780855265861075198881090190505284920581410885950363830131451127387018904728639607372668753109249046707840464876881594185896506371262697868257217488062754637361594352910022190227237953540282162231147699265142164623465337280610190892470279654386272723760887111753067292988287956381022028725288845603024605833650847697724636088418782911705757980221361510892370739837402705040814150778298018509675199917931423568797098139493145394232981571448400646089157848498064505852923746440139
e = 3
ct = 183001753190025751114220069887230720857448492282044619321040127443487542179613757444809112210217896463899655491288132907560322811734646233820773

# Находим кубический корень
def find_cube_root(ct):
    low = 0
    high = ct

    while low <= high:
        mid = (low + high) // 2
        mid_cubed = mid**3

        if mid_cubed == ct:
            return mid
        elif mid_cubed < ct:
            low = mid + 1
        else:
            high = mid - 1

    return None

# Проверяем если ct^3 < n
if ct**3 < n:
    pt = find_cube_root(ct)
    if pt is not None:
        decrypted = long_to_bytes(pt)
        print(f"Дэшифрованный флаг: {decrypted.decode()}")
    else:
        print("Кубический корень не найден")
else:
    print("Шифротекст слишком велик для данной атаки")